name: Telegram File to Link Bot
on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'  # Ø±ÙˆØ²Ø§Ù†Ù‡ Ø§Ø¬Ø±Ø§ Ø´ÙˆØ¯

jobs:
  telegram-bot:
    runs-on: ubuntu-latest
    steps:
    - name: Install required packages
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          python3 \
          python3-pip \
          ffmpeg \
          wget \
          curl

    - name: Install Python dependencies
      run: |
        pip3 install \
          python-telegram-bot \
          pyrogram \
          requests \
          ffmpeg-python \
          python-dotenv

    - name: Create Telegram bot script
      run: |
        cat > telegram_bot.py << 'EOF'
#!/usr/bin/env python3
import os
import logging
import requests
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from ffmpeg import FFmpeg

# ØªÙ†Ø¸ÛŒÙ…Ø§Øª
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
NGROK_TOKEN = os.getenv("NGROK_AUTH_TOKEN")
logging.basicConfig(level=logging.INFO)

class FileToLinkBot:
    def __init__(self):
        self.ngrok_url = None
        
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text(
            "ðŸ¤– Ø³Ù„Ø§Ù…! Ù…Ù† Ø±Ø¨Ø§Øª ØªØ¨Ø¯ÛŒÙ„ ÙØ§ÛŒÙ„ Ø¨Ù‡ Ù„ÛŒÙ†Ú© Ù‡Ø³ØªÙ…\n\n"
            "ðŸ“ Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒØ¯ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø±Ùˆ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:\n"
            "â€¢ ðŸ“¹ ÙˆÛŒØ¯ÛŒÙˆ (Ú©ÛŒÙÛŒØª Ú©Ø§Ù‡Ø´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯)\n"
            "â€¢ ðŸ“· Ø¹Ú©Ø³\n"
            "â€¢ ðŸ“„ documentos\n"
            "â€¢ ðŸŽµ ØµÙˆØª\n\n"
            "ðŸ”— Ø¨Ø¹Ø¯ Ø§Ø² Ø¢Ù¾Ù„ÙˆØ¯ØŒ Ù„ÛŒÙ†Ú© Ù…Ø³ØªÙ‚ÛŒÙ… Ø¯Ø±ÛŒØ§ÙØª Ù…ÛŒâ€ŒÚ©Ù†ÛŒØ¯"
        )

    async def handle_file(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            message = update.message
            file_type = None
            
            if message.video:
                file = message.video
                file_type = "video"
                await message.reply_text("ðŸŽ¥ ÙˆÛŒØ¯ÛŒÙˆ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯! Ø¯Ø± Ø­Ø§Ù„ Ú©Ø§Ù‡Ø´ Ú©ÛŒÙÛŒØª...")
                
            elif message.document:
                file = message.document
                file_type = "document"
                await message.reply_text("ðŸ“„ ÙØ§ÛŒÙ„ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯! Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´...")
                
            elif message.photo:
                file = message.photo[-1]  # Ø¨Ø²Ø±Ú¯ØªØ±ÛŒÙ† Ø³Ø§ÛŒØ²
                file_type = "photo"
                await message.reply_text("ðŸ“· Ø¹Ú©Ø³ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯! Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´...")
                
            elif message.audio:
                file = message.audio
                file_type = "audio"
                await message.reply_text("ðŸŽµ ÙØ§ÛŒÙ„ ØµÙˆØªÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯! Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´...")
            else:
                await message.reply_text("âš ï¸ Ù„Ø·ÙØ§ ÛŒÚ© ÙØ§ÛŒÙ„ Ù…Ø¹ØªØ¨Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯")
                return

            # Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„
            file_obj = await file.get_file()
            original_file = await file_obj.download_to_drive()
            
            # Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙØ§ÛŒÙ„
            if file_type == "video":
                processed_file = self.reduce_video_quality(original_file)
            else:
                processed_file = original_file
            
            # Ø¢Ù¾Ù„ÙˆØ¯ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ù…ÙˆÙ‚Øª
            download_link = await self.upload_to_server(processed_file)
            
            # Ø§Ø±Ø³Ø§Ù„ Ù„ÛŒÙ†Ú© Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±
            await message.reply_text(
                f"âœ… ÙØ§ÛŒÙ„ Ø´Ù…Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª!\n\n"
                f"ðŸ”— Ù„ÛŒÙ†Ú© Ø¯Ø§Ù†Ù„ÙˆØ¯ Ù…Ø³ØªÙ‚ÛŒÙ…:\n{download_link}\n\n"
                f"ðŸ“Š Ø­Ø¬Ù… ÙØ§ÛŒÙ„: {os.path.getsize(processed_file) // 1024}KB\n"
                f"ðŸ’¡ Ø§ÛŒÙ† Ù„ÛŒÙ†Ú© Û²Û´ Ø³Ø§Ø¹Øª Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª"
            )
            
            # Ø­Ø°Ù ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ‚Øª
            os.remove(original_file)
            if processed_file != original_file:
                os.remove(processed_file)
                
        except Exception as e:
            logging.error(f"Error: {e}")
            await message.reply_text("âŒ Ø®Ø·Ø§ÛŒÛŒ Ø±Ø® Ø¯Ø§Ø¯! Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡å°è¯• Ú©Ù†ÛŒØ¯")

    def reduce_video_quality(self, input_path):
        """Ú©Ø§Ù‡Ø´ Ú©ÛŒÙÛŒØª ÙˆÛŒØ¯ÛŒÙˆ Ø¨Ø§ FFmpeg"""
        output_path = f"compressed_{os.path.basename(input_path)}"
        
        ffmpeg = FFmpeg().input(input_path).output(
            output_path,
            vf='scale=640:360',
            crf=28,
            preset='fast',
            **{'c:v': 'libx264', 'c:a': 'aac'}
        )
        ffmpeg.execute()
        return output_path

    async def upload_to_server(self, file_path):
        """Ø¢Ù¾Ù„ÙˆØ¯ ÙØ§ÛŒÙ„ Ø¨Ù‡ Ø³Ø±ÙˆØ± Ù…ÙˆÙ‚Øª"""
        try:
            # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ngrok Ø¨Ø±Ø§ÛŒ hosting
            os.system(f"./ngrok http 8000 &")
            
            # Ø±Ø§Ù‡ Ø§Ù†Ø¯Ø§Ø²ÛŒ Ø³Ø±ÙˆØ± Ù…ÙˆÙ‚Øª
            import http.server
            import socketserver
            import threading
            
            class FileHandler(http.server.SimpleHTTPRequestHandler):
                def do_GET(self):
                    if self.path == f'/{os.path.basename(file_path)}':
                        self.send_response(200)
                        self.send_header('Content-type', 'application/octet-stream')
                        self.send_header('Content-Disposition', f'attachment; filename="{os.path.basename(file_path)}"')
                        self.end_headers()
                        with open(file_path, 'rb') as f:
                            self.wfile.write(f.read())
                    else:
                        self.send_response(404)
            
            def run_server():
                with socketserver.TCPServer(("", 8000), FileHandler) as httpd:
                    httpd.serve_forever()
            
            server_thread = threading.Thread(target=run_server)
            server_thread.daemon = True
            server_thread.start()
            
            # Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒÙ†Ú© Ngrok
            await asyncio.sleep(5)
            response = requests.get("http://localhost:4040/api/tunnels")
            ngrok_url = response.json()['tunnels'][0]['public_url']
            
            return f"{ngrok_url}/{os.path.basename(file_path)}"
            
        except Exception as e:
            logging.error(f"Upload error: {e}")
            return "https://example.com/upload-failed"

async def main():
    bot = FileToLinkBot()
    
    application = Application.builder().token(TOKEN).build()
    
    application.add_handler(CommandHandler("start", bot.start))
    application.add_handler(MessageHandler(filters.ALL, bot.handle_file))
    
    await application.run_polling()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
EOF

        chmod +x telegram_bot.py

    - name: Download and setup Ngrok
      run: |
        wget -q https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-amd64.tgz
        tar -xzf ngrok-v3-stable-linux-amd64.tgz
        chmod +x ngrok

    - name: Create environment file
      run: |
        cat > .env << EOF
TELEGRAM_BOT_TOKEN=7897337548:AAGudjNDkUM5pUWx93mdc6kFBrSqusuj_NA
NGROK_AUTH_TOKEN=${{ secrets.NGROK_AUTH_TOKEN }}
EOF

    - name: Run Telegram bot
      run: |
        echo "ðŸ¤– Starting Telegram Bot..."
        nohup python3 telegram_bot.py > bot.log 2>&1 &
        echo "âœ… Bot is running in background"
        sleep 10
        echo "ðŸ“‹ Bot log:"
        cat bot.log || echo "No log yet"

    - name: Keep bot alive
      run: |
        echo "ðŸŸ¢ Telegram Bot is running!"
        echo "ðŸ”— Token: 7897337548:AAGudjNDkUM5pUWx93mdc6kFBrSqusuj_NA"
        echo "ðŸ“± Connect with: https://t.me/$(curl -s https://api.telegram.org/bot7897337548:AAGudjNDkUM5pUWx93mdc6kFBrSqusuj_NA/getMe | grep -o '"username":"[^"]*' | cut -d'"' -f4)"
        echo ""
        while true; do
            echo "âœ… Bot active - $(date +'%H:%M:%S')"
            sleep 300
        done
