name: Telegram BigFile Bot

on:
  workflow_dispatch:

jobs:
  run-bot:
    runs-on: ubuntu-latest
    steps:
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install telethon pyngrok requests

      - name: Run Telegram Bot with Telethon + Progress
        env:
          TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
          TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
        run: |
          python - <<'PY'
          import os, asyncio, uuid
          from telethon import TelegramClient, events
          from http.server import SimpleHTTPRequestHandler, HTTPServer
          import threading
          from pyngrok import ngrok

          # ðŸ“Œ Config
          api_id = int(os.environ['TELEGRAM_API_ID'])
          api_hash = os.environ['TELEGRAM_API_HASH']
          bot_token = os.environ['TELEGRAM_BOT_TOKEN']

          # ðŸ“‚ Ù¾ÙˆØ´Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§
          os.makedirs("files", exist_ok=True)
          os.chdir("files")

          # ðŸ“Œ HTTP server
          def start_server():
              from socketserver import ThreadingMixIn
              class ThreadingHTTPServer(ThreadingMixIn, HTTPServer):
                  pass
              httpd = ThreadingHTTPServer(('0.0.0.0', 8080), SimpleHTTPRequestHandler)
              httpd.serve_forever()
          threading.Thread(target=start_server, daemon=True).start()

          # ðŸ“Œ Ngrok
          ngrok.set_auth_token(os.environ['NGROK_AUTH_TOKEN'])
          public_url = ngrok.connect(8080, "http").public_url
          print("ðŸŒ Public URL:", public_url)

          # ðŸ“Œ Telethon client
          client = TelegramClient('bot', api_id, api_hash).start(bot_token=bot_token)

          async def progress(current, total, chat_id, msg):
              percent = int(current * 100 / total)
              try:
                  await client.edit_message(chat_id, msg.id, f"â¬‡ï¸ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„...\n{percent}% ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡")
              except:
                  pass

          @client.on(events.NewMessage(pattern='/start'))
          async def start(event):
              await event.respond("Ø³Ù„Ø§Ù… ðŸ‘‹ ÙØ§ÛŒÙ„ØŒ ÙˆÛŒØ¯ÛŒÙˆ ÛŒØ§ Ø¹Ú©Ø³ Ø±Ùˆ Ø¨ÙØ±Ø³Øª ØªØ§ Ù„ÛŒÙ†Ú©Ø´Ùˆ Ø¨Ù‡Øª Ø¨Ø¯Ù….")

          @client.on(events.NewMessage)
          async def handler(event):
              if event.message.media:
                  unique_name = f"{uuid.uuid4().hex}"
                  notify = await event.respond("â¬‡ï¸ Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„ Ø´Ø±ÙˆØ¹ Ø´Ø¯ ...")
                  try:
                      path = await client.download_media(
                          event.message.media,
                          file=unique_name,
                          progress_callback=lambda d, t: asyncio.ensure_future(progress(d, t, event.chat_id, notify))
                      )
                      link = f"{public_url}/{os.path.basename(path)}"
                      await event.respond(f"âœ… Ø¯Ø§Ù†Ù„ÙˆØ¯ Ú©Ø§Ù…Ù„ Ø´Ø¯!\nðŸ“¥ Ù„ÛŒÙ†Ú© Ø¯Ø§Ù†Ù„ÙˆØ¯:\n{link}")
                  except Exception as e:
                      await event.respond(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„: {str(e)}")

          print("ðŸ¤– Bot started, running for ~1 hour...")
          client.run_until_disconnected()
          PY
